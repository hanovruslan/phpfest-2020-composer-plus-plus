## Что будет в докладе ##

Должен признаться, что моё изучение внутренней кухни composer все еще в процессе

Хотя на текущий момент общая картина сформирована, отдельные компоненты и вообще куски исходников не изучены совсем или плохо изучены. В этом смысле название доклада конечно кликбейт.

Но с другой стороны изучение расширения возможностей composer-а идет (за редким исключением) через способы, которые в официальной документации считаются уместными

## Введение в Composer (1) ##

Терминология или первая из двух реальных проблем в программировании в нашей теме тоже важна. Поэтому для начала надо поработать над официальными терминами
Менеджер. Слишком широкий термин. В моем докладе уместно его заменить (или сузить предназначение) на "Управление". Какое именно управление я поясню чуть позже.

## Введение в Composer (2) ##

(Цитата, точнее перевод)
Composer не является менеджером пакетов в том смысле, в каком являются yum или apt. Да, он имеет дело с "пакетами" или библиотеками, но управляет ими для каждого проекта, устанавливая их в каталог (например по умолчанию, vendor) внутри вашего проекта.

(Цитата 2, точнее перевод)
По умолчанию он ничего не устанавливает глобально. Таким образом, это диспетчер зависимостей. Однако для удобства он поддерживает "глобальный" проект с помощью команды composer global.

Разница между "классическим" менеджером типа apt и composer-ом в том, что первый как правило требует привилегированного доступа для манипуляции пакетами. Другими словами apt (или yum или другие) работают на уровне операционной системы.

Вообще, кроме проектного уровня, привычного для php и уровня операционной системы, есть еще так называемый пользовательский, то есть то, что "глобально" для текущего пользователя.

Если взглянуть на все уровни то получается

1. Системный уровень, или уровень операционной системы. Требуется привилегированный доступ.
2. Пользовательский уровень, или уровень текущего пользователя для всех проектов. "Глобальный" в контексте composer-а. Может потребоваться привилегированный доступ. Привет npm.
3. Проектный уровень. Обычный уровень для проекта. С точки зрения devops\12factor и т.п. это должен быть дефолтный уровень

## Введение в Composer ##

> Незаменимым инструмент для PHP

Альтернативы таки есть

- Makefile
- Gradle
- PHing
- dpkg
- Другие инструменты построенные вокруг автоматизации работы задачами

Но, нативность composer-а (пишем на php для php) и его высокое качество, сделало его лидером.

Хотя не без проблем. В частности, он не позиционируется как инструмент сборки, который

## Схема работы ##

Очень упрощенно схема работы выглядит вот так

На pre- и post- события можно подписываться как статически через composer.json так и динамически через плагины.

Composer построен на базе symfony/console, в частности используется в каком-то смысле стандартная шина событий для консольного приложения.

Упомянутые плагины при инициализации могут подписаться на любые события composer-а

## Схема работы (1) ##

Автолоадер

Автолоадер (или набор доступных файлов и классов) есть вшитый в тот композер, который вы скачали или еще каким-то способом установили и запускаете. Например, я бы посоветовал для дебага плагинов использовать версию композера не в phar-файле, а в исходниках.
Кроме того после установки всех пакетов будет доступен автолоадер собранный конкретно для этого проекта. В случае когда вы хотите использовать локальный плагин, который не прописан по PSR-0/4, то он конечно для работы не будет доступен.

## Схема работы (2) ##

Логгер также базируется на решении от сообщества symfony (привет PSR-3)

Важное замечание, первые версии composer-а стали выходить после релиза symfony 2.0 но до symfony 2.1, и только где-то начиная с версии 2.7 официально composer стал сильно зависить от symfony пакетов. В данном случае зависеть в хорошем смысле.

Потому что зачем делать то, что уже есть готовое в сообществе - логгер, шина событий, манипуляции с файловой системой и управление процессами.
