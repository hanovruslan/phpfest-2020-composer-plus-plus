## Что будет в докладе

Должен признаться, что моё изучение внутренней кухни composer все еще в процессе.
Я честно пробовал влиться в стройные ряды разработчиков composer-а, даже один реквест от меня приняли.
Но. Совмещать обычную работу с реалиями open source довольно сложно.

На текущий момент общая картина сформирована, отдельные компоненты и вообще куски исходников не изучены совсем или плохо изучены.
В этом смысле название доклада кликбейт.

Но с другой стороны изучение расширения возможностей composer-а идет (за редким исключением) через способы, которые в официальной документации считаются уместными.

## Введение Composer (Раздел)

## Что такое composer

Composer - это автоматизация работы с проектом на PHP в парадигме связанных задач. Задачи связаны в направленном ациклическом графе.

Задачи и разнообразные настройки для них описываются в специальном файле с настройками, по умолчанию он называется composer.json,
но это как и некоторые другие настройки запуска composer можно переопределить через переменные окружения.

Файл настроек имеет схему валидации, которая поставляется внутри composer.phar файла.
Перед тем как выполняется любая задача, composer проверяет файл настроек через эту схему.

## А есть ли альтернативы? (2)

Вообще я бы рекомендовал регурялно задавать себе вопрос - а можно ли делать иначе то, что я сейчас делаю.
Конкретно в этом случае, использовать не composer, а что-то другое

А альтернативы таки есть

1. про apt и подобные можно точно сказать что это точно возможно (но очень нетипично) и некоторые крупные компании подобным образом поставляют свои php приложения.
Специфично для выбранной операционной системы

2. make и его файл настроек makefile - процесс преобразования и компоновки файлов. Неспецифично для операционной системы,
хотя связано в возможностями командной оболочки

3. PHing - Сосредоточен на задачах поставки приложений, но то общий так сказать каркас построенный вокруг концепции перечисления задач, которые умеют
делать различные преобразования файлов в том числе с помощью сторонних (относительно phing) инструментов.
Довольно старый и негибкий инструмент.

4. Gradle - гордость мира Java, мощный и актуальный инструмент для автоматизации задач разработки. Так как по дизайну тоже является каркасом (фреймворком) для автоматизации,
то при достоточных компетенций в Java или Grovvy а с недавних пор еще и Kotlin можно использовать и для php проектов

5. Другие инструменты типа Grunt из мира javascript теоретически тоже применимы но с большим количеством оговорок.

Учитывая историю развития и composer-а и представленных инструментов и нативность composer-а (пишем на php для php) и его высокое качество,
composer - разумный выбор.

Хотя не без проблем. В частности, он не позиционируется как инструмент сборки, который делает всё от инициализации проекта и до его деплоя.

И тут вина не столько самого composer-а, сколько давно устоявшихся практик разработки в мире PHP, которые говорят нам о том,
что код PHP не самостоятельное приложение, а обычно идет в комплекте с fpm и nginx.

И еще типичная для приложений PHP работа через исходники, а не как, например, в мире java, через так называемые артефакты,
готовые к запуску приложения или готовые к подключению библиотеки в виде  единого файла.

## Введение в Composer (1)

Терминология или первая из двух реальных проблем в программировании в нашей теме тоже важна. Поэтому для начала надо поработать над официальными терминами
Менеджер. Слишком широкий термин. В моем докладе уместно его заменить (или сузить предназначение) на "Управление". Какое именно управление я поясню чуть позже.

(Цитата, точнее перевод)
Composer не является менеджером пакетов в том смысле, в каком являются yum или apt. Да, он имеет дело с "пакетами" или библиотеками,
но управляет ими для каждого проекта, устанавливая их в каталог (например по умолчанию, vendor) внутри вашего проекта.

## Введение в Composer (2)

(Цитата 2, точнее перевод)
По умолчанию он ничего не устанавливает глобально. Таким образом, это диспетчер зависимостей.
Однако для удобства он поддерживает "глобальный" проект с помощью команды composer global.

--Разница между "классическим" менеджером типа apt и composer-ом в том, что первый как правило требует привилегированного доступа для манипуляции пакетами.
--Другими словами apt (или yum или другие) работают на уровне операционной системы.

--Вообще, кроме проектного уровня, привычного для php и уровня операционной системы, есть еще так называемый пользовательский,
--то есть то, что "глобально" для текущего пользователя.

--Если взглянуть на все уровни то получается

--1. Системный уровень, или уровень операционной системы. Требуется привилегированный доступ.
--2. Пользовательский уровень, или уровень текущего пользователя для всех проектов. "Глобальный" в контексте composer-а. Может потребоваться привилегированный доступ.
--3. Проектный уровень. Обычный уровень для проекта. С точки зрения 12 factor и т.п. это должен быть уровень по умолчанию

Возвращаюясь в обещанию пояснить употребление термина "управление".

1. Управление ПАКЕТАМИ это задачи require/install/update/remove
2. Управление ЗАВИСИМОСТЯМИ это задачи dump-autoload/validate/info/show/why

В глаза бросается то, что задачи по какому-то ни было преобразованию в предложенном разделении сосредоточены в управлении пакетами.
В то время как  в управлении зависимостями это только dump-autoload.
Более того, dump-autoload запускается после всех задач по управлению пакетами по умолчанию.

## Пакеты или зависимости

Таким образом формально вы можете управлять пакетами, не управляя зависимостями. Особенно это важно,
когда в проекте могут появится неявные зависимости - непосредственно транзитивные зависимости или динамические команды, поставляемые в плагинах.

Установленный в проект пакет еще не дает возможность расширять функционал

Но как только вы установили ЗАВИСИМОСТЬ в проект (читать как прописали в автолоад), функционал приложения меняется.
Ну, как правило нужно добавить конфигурацию для этого пакета в приложение. но зависимость может быть например просто неким SDK.

Соответственно, если в зависимости есть ошибка, то она влияет на стабильность приложения.

## Как работает Composer (Раздел)

## Схема работы: Компоненты (1)

Композер - это консольное php приложение упакованное в уже упомянутый артефакт - phar-файл.
В этом приложении есть возможность подключать дополнительный фукнционал через механизм плагинов. Кроме консольной части есть и другие компоненты

## Схема работы: Компоненты (2)

Автолоадер

Автолоадер (или набор доступных файлов и классов) есть вшитый в тот композер, который вы скачали или еще каким-то способом установили и запускаете.
Например, я бы посоветовал для дебага плагинов использовать версию композера не в phar-файле, а в исходниках.
Кроме того после установки всех пакетов будет доступен автолоадер собранный конкретно для этого проекта.
В случае когда вы хотите использовать какой-то код в файлах, которые не прописаны по правилам PSR-0/4, то код из этих файлов конечно для работы не будут доступны

## Схема работы: Компоненты (3)

Логгер также базируется на решении от сообщества symfony. Важное замечание - в логгера можно менять уровень детализации логов,
но он дейстителен для всей цепочки задач, связанных с конкретной вызванной командой composer

## Схема работы: Компоненты (4)

Окружение запуска команд: symfony/process, обертка над командной оболочкой.

## Схема работы: Компоненты (4)

Первые версии composer-а стали выходить после релиза symfony 2.0 но до symfony 2.1,
и только где-то начиная с версии 2.7 официально composer стал сильно зависить от symfony пакетов. В данном случае зависеть в хорошем смысле.

Потому что зачем делать то, что уже есть готовое в сообществе - логгер, шина событий, манипуляции с файловой системой и управление процессами.

## Схема работы с плагинами

В консольном приложении иcпользуется шина данных которая позволяет подписаться на любые события composer-а. Их набор варьируется между разными командами

На pre- и post- события можно подписываться как статически через composer.json так и динамически через плагины.

## Популярные плагины

* symfony/flex - Не только лишь каждый знает что это такое в мире symfony
* hirak/prestissimo - это
* brainmaestro/composer-git-hooks - это
* mouf/nodejs-installer - это
* neronmoon/scriptsdev - это

Есть и более экзотические. Например, плагины, которые позволяют патчить содержимое папки vendor или визуализация (картинка или dot файл) всех установленных пакетов
в виде ациклического направленного графа.
Вообще что-то подобное умеет и сам composer, но только в консольном древовидном отображении.
