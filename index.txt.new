## План

## Что будет в докладе

Должен признаться, что моё изучение внутренней кухни composer все еще в процессе.
Я честно пробовал влиться в стройные ряды разработчиков composer-а, даже один реквест от меня приняли.
Но. Совмещать обычную работу с реалиями open source довольно сложно.

На текущий момент общая картина сформирована, отдельные компоненты и вообще куски исходников не изучены совсем или плохо изучены.
В этом смысле название доклада кликбейт.

Но с другой стороны изучение расширения возможностей composer-а идет (за редким исключением) через способы, которые в официальной документации считаются уместными.

Сравнения с аналогами на концептуальном уровне

! Одна максимально полезная тематическая ссылка

## Чего не будет в докладе

 - подробного сравнения с аналогичными инструментами
 - больших цитат из документации
 - лучшие практики composer

## План

- введение, кратко напомню для чего нужен композер и как принципиальнно устроен,
Также будет концептуальное сравниение с похожими инструментами
- схематично опишу как работает композер, из каких компонентов состоит
- проблемы - перечислю небольшой набор практических проблем использования композера в том виде в котором он сейчас существует
- представлю решения перечисленных проблем.
- Заглянем в самое ближайшее будушее и посмотрим на изменения в composer 2.0
- ну и каждый хороший доклад должен быть с выводами )

## Введение в composer

Composer - это автоматизация работы с проектом на PHP в парадигме связанных задач. Задачи связаны в направленном ациклическом графе.

Задачи и разнообразные настройки для них описываются в специальном файле с настройками, по умолчанию он называется composer.json,
но это как и некоторые другие настройки запуска composer можно переопределить через переменные окружения.

Файл настроек имеет схему валидации, которая поставляется внутри composer.phar файла.
Перед тем как выполняется любая задача, composer проверяет файл настроек через эту схему.

## Альтернативы

Вообще я бы рекомендовал регурялно задавать себе вопрос - а можно ли делать иначе то, что я сейчас делаю.
Конкретно в этом случае, использовать не composer, а что-то другое

А альтернативы таки есть

1. phing - Сосредоточен на задачах поставки приложений, но то общий так сказать каркас построенный вокруг концепции перечисления задач, которые умеют
делать различные преобразования файлов в том числе с помощью сторонних (относительно phing) инструментов.
Довольно старый и негибкий инструмент.

2. make и его файл настроек makefile - процесс преобразования и компоновки файлов. Неспецифично для операционной системы,
хотя связано в возможностями командной оболочки

3. Gradle - гордость мира Java, мощный и актуальный инструмент для автоматизации задач разработки. Так как по дизайну тоже является каркасом (фреймворком) для автоматизации,
то при достоточных компетенций в Java или Grovvy а с недавних пор еще и Kotlin можно использовать и для php проектов

## Альтернативы, есть но ...

Учитывая историю развития и composer-а и представленных инструментов и нативность composer-а (пишем на php для php) и его высокое качество,
composer - разумный выбор.

Хотя не без проблем. В частности, он не позиционируется как инструмент сборки, который делает всё от инициализации проекта и до его деплоя.

И тут вина не столько самого composer-а, сколько давно устоявшихся практик разработки в мире PHP, которые говорят нам о том,
что код PHP не самостоятельное приложение, а обычно идет в комплекте с fpm и nginx.

И еще типичная для приложений PHP работа через исходники, а не как, например, в мире java, через так называемые артефакты,
готовые к запуску приложения или готовые к подключению библиотеки в виде  единого файла.

## Введение

Терминология или первая из двух реальных проблем в программировании в нашей теме тоже важна. Поэтому для начала надо поработать над официальными терминами
Менеджер. Слишком широкий термин. В моем докладе уместно его заменить (или сузить предназначение) на "Управление". Какое именно управление я поясню чуть позже.

(Цитата, точнее перевод)
Composer не является менеджером ПАКЕТОВ в том смысле, в каком являются yum или apt. Да, он имеет дело с ПАКЕТАМИ или библиотеками,
но управляет ими для каждого проекта, устанавливая их в каталог (например по умолчанию, vendor) внутри вашего проекта.

## Введение (2)

1. Управление ПАКЕТАМИ это задачи require/install/update/remove
2. Управление ЗАВИСИМОСТЯМИ это задачи dump-autoload/validate/check-platform-reqs/info/и т.д.

В этом разделении в глаза бросается то, что задачи по преобразованию проекта сосредоточены в управлении ПАКЕТАМИ.
В то время как  в управлении ЗАВИСИМОСТЯМИ это только dump-autoload.
Более того, dump-autoload запускается после всех задач по управлению ПАКЕТАМИ по умолчанию.

## Пакеты или зависимости

Таким образом формально вы можете управлять пакетами, не управляя зависимостями. Особенно это важно,
когда в проекте могут появится неявные зависимости или динамические команды, поставляемые в плагинах, как неявные зависимости особого типа.

Установленный в проект ПАКЕТ еще не дает возможность расширять функционал.

Но как только в проекте появилась ЗАВИСИМОСТЬ, функционал приложения меняется - появляются фичи и баги ))
Еще как правило нужно добавить конфигурацию для этого пакета в приложение. Хотя иногда зависимость может быть например просто неким SDK.

## Как работает Composer

Мы разобрались (или вспомнили) с тем для чего нужен композер и с какими категориями он работает. Пора разобраться в том (или напомнить) как он работает

## Схема работы: Компоненты (1)

Композер - это консольное php приложение упакованное в уже упомянутый артефакт - phar-файл. Аналогичным образом можно пользоваться например php-cs-fixer-ом, или phpunit-ом
В этом приложении есть возможность подключать дополнительный фукнционал через механизм плагинов (об этом чуть позже). Кроме консольной части есть и другие компоненты

## Схема работы: Компоненты (2)

Автолоадер

Автолоадер (или набор доступных исходников) есть вшитый в сам композер.
Также после установки всех зависимостей будет доступен автолоадер, собранный конкретно для этого проекта.
В случае, когда вы хотите использовать какой-то код из файлов, которые не прописаны по правилам PSR-0/4, то код из этих файлов для работы НЕ БУДЕТ ДОСТУПЕН

## Схема работы: Компоненты (3)

Еще один компонент - логгер. Его предназначение очевидно в том, чтобы оповещать о ходе выполнения команд.
Он также базируется на решении от сообщества symfony. Важное замечание - в логгере можно менять уровень детализации логов,
но этот уровень дейстителен для всей цепочки задач в данном вызове composer-а

## Схема работы: Компоненты (4)

Окружение запуска команд: symfony/process, обертка над командной оболочкой.

## Схема работы без плагинов

Как композер выполняет команду которую вы ему задали. Он
1 - как я сказал в самом налача провалидирует файл composer.json
2 - породит события, на которые можно среагировать до выполнения собственно команды
3 - выболнение команды
4 - порождение другого набора событий

Подписаться на эти события и таким образом расширить функционал композера можно через плагины

## Плагин

1 - Плагин это пакет особого типа
2 - Он как уже понятно может взаимодействовать с шиной событий композера
3 - три обязательных метода и один опциональный. На самом деле самый полезный.

## Схема работы с плагинами

Почти все плагины срабатываю непосредственно перед командой и после.
Но есть и особые события подписка на которые даёт возможность расширять
композера на самых ранних стадиях выполнения команды. например событие init или command
второе событие нужно для манипуляции входными параметрами для композера и его выхлопом.

## Популярные плагины

* hirak/prestissimo - при установленном php расширении curl, параллелльное скачивание пакетов при первичной установке

* brainmaestro/composer-git-hooks - обертка над скриптами git-hooks, далее будет пример использования этого плагина

* mouf/nodejs-installer

как очевидно из названия - возможность установить рантайм nodejs и заодно npm в папку вендор. Так чтобы в скриптах оба были доступны.

* neronmoon/scriptsdev - для того чтобы иметь в composer.json скрипты которые доступны только в режиме dev. Если запустить composer с ключем --no-dev, то скрипт не будет доступен.

Прямая аналогия с парой "require" и "require-dev"

* symfony/flex* - широко известных в кругах разработчиков, знакомых с symfony, возможность вносить изменения в определенные части проекта, в основном это конфиги бандлов

## Экзотические плагины

Представленные плагины я по разным причинам изучал и даже пробовал использовать,
но в итоге дальше экспериментов дело не пошло

* clue/graph-composer -

это визуализация зависимостей в проекте в формате DOT или сразу в графическом, в png

* wikimedia/composer-merge-plugin -

это возможность объединять в рантайме несколько compose.json файлов

* slince/composer-registry-manager -

это возможность переключаться между зеркалами реестра пакетов композера

* Composer Patches - это небольшой список плагинов предназначение которых в накладывании патчей на директорию vendor

## Примеры использования плагинов

## Проблемы
1. много скриптов

вы активно используете скрипты, которые можно прописать в composer.json
и в какой-то момент их становится очень много и даже очень
эффективное именование именование этих скриптов не помогает не заблудиться.

Еще как правило много скритов похожых друг на друга, отличающихся парочкой параметров запуска

1. вывод результатов выполнения команды

как я говорил вышел настройка уровня детализации вывод выполнения команд есть одна для всех.
опять же когда у вас много разнообразных команд и скриптом
очется выдавать им разные уровни детализации вывода

1. переменные окружения

Они есть и обрабатываются, но их очень ограниченный нерасширяемый набор.
Очевидно что для богатой автоматизации нужен свой набор переменных окружения и обрабоки оных

1. фоновые процессы
1. редактирование всех настроек из консоли (Composer 2.0*)
1. оффлайн-режим (Composer 2.0)
1. повторный запуск после успешного шага

## Фоновый процесс, пример

## Фоновый процесс, костыль

## Решения

## Много скриптов, решение

## Вывод результатов выполнения команды, решение

## Вывод результатов выполнения команды, решение (2)

## Переменные окружения, решение

## Фоновый процесс, решение

## Редактирование composer.json из консоли, решение

## Повторный запуск после успешного шага, решение

## Composer 2.0

## Выводы
