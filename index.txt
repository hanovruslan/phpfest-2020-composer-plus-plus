## Что будет в докладе

Должен признаться, что моё изучение внутренней кухни composer все еще в процессе.
Я честно пробовал влиться в стройные ряды разработчиков composer-а, даже один реквест от меня приняли.
Но. Совмещать обычную работу с реалиями open source довольно сложно.

На текущий момент общая картина сформирована, отдельные компоненты и вообще куски исходников не изучены совсем или плохо изучены.
В этом смысле название доклада кликбейт.

Но с другой стороны изучение расширения возможностей composer-а идет (за редким исключением) через способы, которые в официальной документации считаются уместными.

## Введение Composer (Раздел)

## Что такое composer

Composer - это автоматизация работы с проектом на PHP в парадигме связанных задач. Задачи связаны в направленном ациклическом графе.

Задачи и разнообразные настройки для них описываются в специальном файле с настройками, по умолчанию он называется composer.json,
но это как и некоторые другие настройки запуска composer можно переопределить через переменные окружения.

Файл настроек имеет схему валидации, которая поставляется внутри composer.phar файла.
Перед тем как выполняется любая задача, composer проверяет файл настроек через эту схему.

## Aльтернативы

Вообще я бы рекомендовал регурялно задавать себе вопрос - а можно ли делать иначе то, что я сейчас делаю.
Конкретно в этом случае, использовать не composer, а что-то другое

А альтернативы таки есть

2. make и его файл настроек makefile - процесс преобразования и компоновки файлов. Неспецифично для операционной системы,
хотя связано в возможностями командной оболочки

1. PHing - Сосредоточен на задачах поставки приложений, но то общий так сказать каркас построенный вокруг концепции перечисления задач, которые умеют
делать различные преобразования файлов в том числе с помощью сторонних (относительно phing) инструментов.
Довольно старый и негибкий инструмент.

3. Gradle - гордость мира Java, мощный и актуальный инструмент для автоматизации задач разработки. Так как по дизайну тоже является каркасом (фреймворком) для автоматизации,
то при достоточных компетенций в Java или Grovvy а с недавних пор еще и Kotlin можно использовать и для php проектов

## Альтернативы, есть но ...

Учитывая историю развития и composer-а и представленных инструментов и нативность composer-а (пишем на php для php) и его высокое качество,
composer - разумный выбор.

Хотя не без проблем. В частности, он не позиционируется как инструмент сборки, который делает всё от инициализации проекта и до его деплоя.

И тут вина не столько самого composer-а, сколько давно устоявшихся практик разработки в мире PHP, которые говорят нам о том,
что код PHP не самостоятельное приложение, а обычно идет в комплекте с fpm и nginx.

И еще типичная для приложений PHP работа через исходники, а не как, например, в мире java, через так называемые артефакты,
готовые к запуску приложения или готовые к подключению библиотеки в виде  единого файла.

## Введение в Composer

Терминология или первая из двух реальных проблем в программировании в нашей теме тоже важна. Поэтому для начала надо поработать над официальными терминами
Менеджер. Слишком широкий термин. В моем докладе уместно его заменить (или сузить предназначение) на "Управление". Какое именно управление я поясню чуть позже.

(Цитата, точнее перевод)
Composer не является менеджером ПАКЕТОВ в том смысле, в каком являются yum или apt. Да, он имеет дело с ПАКЕТАМИ или библиотеками,
но управляет ими для каждого проекта, устанавливая их в каталог (например по умолчанию, vendor) внутри вашего проекта.

## Введение в Composer (2)

1. Управление ПАКЕТАМИ это задачи require/install/update/remove
2. Управление ЗАВИСИМОСТЯМИ это задачи dump-autoload/validate/check-platform-reqs/info/и т.д.

В этом разделении в глаза бросается то, что задачи по преобразованию проекта сосредоточены в управлении ПАКЕТАМИ.
В то время как  в управлении ЗАВИСИМОСТЯМИ это только dump-autoload.
Более того, dump-autoload запускается после всех задач по управлению ПАКЕТАМИ по умолчанию.

## Пакеты или зависимости

Таким образом формально вы можете управлять пакетами, не управляя зависимостями. Особенно это важно,
когда в проекте могут появится неявные зависимости или динамические команды, поставляемые в плагинах, как неявные зависимости особого типа.

Установленный в проект ПАКЕТ еще не дает возможность расширять функционал.

Но как только в проекте появилась ЗАВИСИМОСТЬ, функционал приложения меняется - появляются фичи и баги ))
Еще как правило нужно добавить конфигурацию для этого пакета в приложение. Хотя иногда зависимость может быть например просто неким SDK.

## Как работает Composer (Раздел)

## Схема работы: Компоненты (1)

Композер - это консольное php приложение упакованное в уже упомянутый артефакт - phar-файл.
В этом приложении есть возможность подключать дополнительный фукнционал через механизм плагинов (об этом чуть позже). Кроме консольной части есть и другие компоненты

## Схема работы: Компоненты (2)

Автолоадер

Автолоадер (или набор доступных исходников) есть вшитый в сам композер.
Также после установки всех зависимостей будет доступен автолоадер, собранный конкретно для этого проекта.
В случае, когда вы хотите использовать какой-то код из файлов, которые не прописаны по правилам PSR-0/4, то код из этих файлов для работы НЕ БУДЕТ ДОСТУПЕН

## Схема работы: Компоненты (3)

Еще один компонент - логгер. Его предназначение очевидно в том, чтобы оповещать о ходе выполнения команд.
Он также базируется на решении от сообщества symfony. Важное замечание - в логгере можно менять уровень детализации логов,
но этот уровень дейстителен для всей цепочки задач в данном вызове composer-а

## Схема работы: Компоненты (4)

Окружение запуска команд: symfony/process, обертка над командной оболочкой.

## Схема работы: Компоненты (4)

Первые версии composer-а стали выходить после релиза symfony 2.0 но до symfony 2.1,
и только где-то начиная с версии 2.7 официально composer стал сильно зависить от symfony пакетов. В данном случае зависеть в хорошем смысле.

Потому что зачем делать то, что уже есть готовое в сообществе - логгер, шина событий, манипуляции с файловой системой и управление процессами.

## Схема работы: Компоненты (4)

## Плагины

Плагин - это обычный пакет Composer, который поставляет свой код как часть пакета и может также зависеть от других пакетов.

## Схема работы с плагинами

В консольном приложении иcпользуется шина событий, которая позволяет встраиваться в поток исполения composer-а. Набор доступных в шине событий варьируется между разными командами.

На события можно подписываться как статически через composer.json так и динамически через плагины.

## Популярные плагины

* symfony/flex - Не только лишь каждый знает что это такое в мире symfony
* hirak/prestissimo - это
* brainmaestro/composer-git-hooks - это
* mouf/nodejs-installer - это
* neronmoon/scriptsdev - это

Есть и более экзотические. Например, плагины, которые позволяют патчить содержимое папки vendor или визуализация (картинка или dot файл) всех установленных пакетов
в виде ациклического направленного графа.
Вообще что-то подобное умеет и сам composer, но только в консольном древовидном отображении.
